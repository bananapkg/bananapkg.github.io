<!DOCTYPE html>
<html lang="pt-br">
<head>
	<title>BananaPKG - Simples Gerenciador de pacotes de baixo nível</title>
	<meta charset="utf-8">
	<style>
		body{font-size: 1.2em; color: #232323;font-family: courier new; margin: 8%;}
		hr{border: 1px dashed; color: #333; margin-top: 4%; margin-bottom: 4%;}
		h3{margin-top: 3%; margin-bottom: 3%;}
		li#categoria{margin: 0.5%;}
                .sub{color: #FF3C12;}
		#code{background-color: #b8b8b8; padding: 1%; color: #232323;}
		.titulo{color: #007e4d; background-color: #E1E1E1; padding: 0.5%;}
                #nota
                {
                 background-color: #292929;
                 color: #00FFB2;
                 padding: 1%; 
                 margin-top: 2%; margin-bottom: 2%; 
                 box-shadow: 1px 10px 10px 0.2px #C6C6C6;
                }
                #nota li{color: white; margin: 1%;}
                #parametros{color: #900C3F;}
	</style>
</head>
<body>
<b>Atualização: 07/02/2019</b>
<h2>Documentação</h2>
<h3>Índice</h3>
<ol id="principal">
	<li id="categoria">Prefácio</li>
		<ul>
	            <li><a href="#bananapkgprojeto">O projeto BananaPKG</a></li>
		    <li><a href="#inspirado">BananaPKG é fork de qual gerenciador?</a></li>
		    <li><a href="#linguagem-bananapkg">Em qual linguagem é escrito o BananaPKG</a></li>
	            <li><a href="#bananapkg-alto-nivel">BananaPKG é de alto nível?</a></li>
		    <li><a href="#formato-pacote">Qual o formato do pacote?</a></li>
		    <li><a href="#passar-amigos">Posso passar os pacotes que criei para amigos?</a></li>
		</ul>
	<li id="categoria" href='#modo-de-utilizacao'>Modo de Utilização</li>
		<ul>
		    <li><a href="#criar-pacote">Como criar um pacote</a></li>
                <ul>
                     <li><a href="#scripts">Scripts do diretório info/</a></li>
                </ul>
		     <li><a href="#instalar-atualizar-pacote">Como instalar/atualizar um pacote</a></li>
		     <li><a href="#remover-pacote">Como remover um pacote</a></li>			
		</ul>
	<li id="categoria" href='#'>Desenvolvimento</li>
                <ul>
		     <li><a href="#listdescremove">/var/lib/banana/{list,desc,remove}</a></li>
		     <li><a href="#etcbanana">Arquivo de configuração em /etc/banana</a></li>
		     <li><a href="#coresh">core.sh</a></li>
                </ul>
	<li id="categoria" href='#compilacao'>Compilação um caminho correto</li>
                <ul>
		     <li><a href="#compilacao">Quais parâmetros devo usar na compilação?</a></li>
		     <li><a href="#enfeites">Enfeites do pacote</a></li>
		     <li><a href="#strip">Strip Now</a></li>
                </ul>
</ol>

<hr>

<!--
#####################################
O PROJETO
#####################################
-->

<h3 id="bananapkgprojeto" class="titulo">O projeto BananaPKG</h3>
O bananaPKG foi iniciado com suas ferramentas de baixo nível indenpendentes. Porém na versão 1.5, passou a ser uma ferramenta única que tem suas chamadas (create, install, upgrade, remove, search)</b><br><br>
<br>
Você pode conferir a sintaxe no indice: <a href="#modo-de-utilizacao">Modo de utilização</a>


<h3 id="inspirado" class="titulo">BananaPKG é fork de qual gerenciador?</h3>
Nenhum. O bananaPKG foi <i>criado do zero</i>, porém teve inspiração nos utilitários <b>installpkg</b>, <b>upgradepkg</b>, <b>removepkg</b> da distribuição Slackware que também é escrito do zero e em Shell Script. O 


<h3 id="linguagem-bananapkg" class="titulo">Em qual linguagem é escrito o BananaPKG</h3>
O BananaPKG foi criado na linguagem de programação Shell Bash. Feito para ser simples, fácil e agradável de se utilizar... Em poucos passos você já pode criar os seus pacotes e passar para seus amigos.


<h3 id="bananapkg-alto-nivel" class="titulo">BananaPKG é de alto nível?</h3>
Não! BananaPKG é uma ferramenta de baixo nível, com ela você pode <b>Criar</b>, <b>Instalar</b>, <b>Atualizar</b>, <b>Remover</b> e <b>procurar</b> pacotes do seu sistema.<br>
Ou seja, ela serve para gerenciar os pacotes e cuida-los. Se caso você seja um bom programador de Shell e queira fazer uma extensão de alto nível que resolva dependências, há uma array/lista no arquivo info/desc que contém as dependências do pacote.
Essa array foi criada e pensada para um uso futuro para quem deseja fazer uma extensão. Por padrão o projeto não terá oficialmente uma extensão para esta finalidade.

<h3 id="formato-pacote" class="titulo">Qual o formato do pacote?</h3>
O formato de pacote próprio é o <b>.mz</b>. Como inicialmente o BananaPKG foi criado para suprir a necessidade da distribuição Linux mazonOS, que é uma distribuição criada do zero e não possuia um gerenciador de pacotes, acabou que o formato ficou e vai continuar como .mz.<br>
Este formato é um simples arquivo compactado com o utilitário tar e comprimido com o utilitário xz. 
Mas sinta-se a vontade para modificar ao seu gosto a extensão se assim necessitar... O programa está bem modularizado e um bom programador em Shell consegue fazer a modificação para sua necessidade.

<h3 id="passar-amigos" class="titulo">Posso passar os pacotes que criei para amigos?</h3>
Com toda certeza. Mas para quem ser o receptor do pacote vai precisar utilizar o BananaPKG também. Isso devido ao fato que o pacote que ele gera depende do instalador para tratar o pacote antes de instalar.

<hr>



<!--
#####################################
MODO DE UTILIZAÇÃO
#####################################
-->



<h2 id="modo-de-utilizacao">Modo de utilização</h2>

<h3 id="criar-pacote" class="titulo">Como criar um pacote</h3>
<b>banana [create] [nome_do_pacote-versão-build.mz]</b><br><br>

<div id="code">
<b>-c</b>, <b>create</b> <b id="parametros">Criação de pacote(s)</b><br>
</div>

<p>Após a você ter feito o fakeroot do pacote, você irá necessitar seguir um passo a passo para ter êxito. O primeiro passo é criar um diretório chamado <b>info/</b> e um arquivo dentro do diretório chamado <b>desc</b>. Esse arquivo <b>desc</b> é de muita importância para o pacote. É atráves dele que toda conferência do pacote é feita nos outros utilitários.<br>
Você pode criar manualmente ou automaticamente com a opção <b>-g</b>, <b>generate</b>. Está opção irá criar o diretório info/ e o arquivo desc pronto para edição.</p>

<p>O arquivo desc tem um série de variáveis que precisam ser editadas, sendo que todas <b>menos</b> a array/lista <b>dep</b> precisa ser preenchida, ás variáveis são:</p>

<div id="code">
# Nome do mantenedor do pacote<br/>
<b>maintainer</b>=''<br/>
<br/>
# Nome do pacote<br/>
<b>pkgname</b>=''<br/>
<br/>
# Versão do Software<br/>
<b>version</b>=''<br/>
<br/>
# Versão de construção do pacote (build)<br/>
<b>build</b>=''<br/>
<br/>
# SMALL Description of Software, NO Trespassing |<br/>
#=============RULER=====================================================|<br/>
<b>desc</b>=" "<br/>
#=======================================================================|<br/>
<br/>
# URL SOFTWARE<br/>
<b>url</b>=''<br/>
<br/>
# What packages do your package need to run?<br/>
# This array is optional.<br/>
<b>dep</b>=(" ")<br/>
</div>


<p>Preencha todas as variáveis em letras minúsculas, lembre-se de por no campo <b>pkgname</b> o nome correto do programa e no campo <b>version</b> a versão correta do programa. Todos estes campos são usados não só para imprimir na tela para o usuário, mas também para conferencias importantes :)<br>
Decifrando os campos:</p>

<p><b class='sub'>maintainer</b><br/>
Este campo necessita ter o nome do mantenedor do pacote seguido do seu email, o ideal é ser neste e somente neste formato:
Jefferson Rocha <email@email.com></p>

<p><b class='sub'>pkgname</b><br>
Este campo você necessita preencher com o nome do pacote, este campo é conferindo na hora que você cria o pacote, necessita estar igual ao que você vai chamar na linha de comando.</p>

<p><b class='sub'>version</b><br>
Campo de versão do programa, este campo é conferido na hora da criação do pacote, necessita estar igual ao que você vai criar.</p>

<p><b class='sub'>build</b><br>
Este campo é o de construção númerico! Cada vez que você mexer e gerar um novo pacote com o mesmo pacote você precisa incrementar este campo!
Ele é conferido na hora da atualização do pacote juntamente com a versão. Então é um campo muito importante também!<br>
Lembre-se de usar somente números inteiros como (1, 2, 3, 4) etc... e não números quebrados como (0.1, 0.2, 0.3). Números quebrados não serão aceitos.</p>

<p><b class='sub'>desc</b><br>
Neste campo você precisa ter um pouco de mais cuidado, ele é o campo de descrição do programa. Você necessita seguir a régua que tem em cima do campo e não deverá ultrapassar o pipe '|', caso sua descrição seja muito longa vá fazendo a quebra de linha antes do pipe '|'.
Exemplo:<br></p>
<pre>
#=============RULER=====================================================<b>|</b>
<b>desc</b>="Esta descrição é um exemplo prático de como fazer a descrição você
pode ver que eu necessitei quebrar a linha para baixo, mas isso não é um
problema.
É simples, antes do pipe eu quebro para baixo e continuo com a descrição
normalmente ;)
Lembre-se de usar aspas duplas neste campo, pois se você usar aspas sim-
ples tipo Don't não terá poblemas."
#=======================================================================<b>|</b>
</pre>


<p><b class='sub'>url</b><br>
Qual o site do projeto do software que você está empacotando? Adicione aqui!</p>

<p><b class='sub'>dep</b><br>
Se caso o programa que você gerou o pacote necessitar de dependências <strike>o que é quase certeza</strike>, você precisa por neste campo. Ele nada mais é que um array, digamos que o meu pacote imaginário tenha 3 dependências (X, Y, Z), fariamos:</p>
<pre>
<b>dep</b>=("X" "Y" "Z")
</pre>

<h3 id="scripts" class="titulo">Scripts do diretório info/</h3>

Após você ter preenchido todo o arquivo <b>desc</b> você talvez necessite fazer alguns incrementos no seu pacote. Alguns software necessitam fazer uma série de passo a passo para atingir o seu objetivo, dentre estes objetivos: Adicionar links simbólicos, adicionar grupo, usuários etc...<br>
É o caso por exemplo do programa rsync que exige que antes de instalar o mesmo tenha o grupo <b>rsyncd</b> e o usuário <b>rsyncd</b>. Para isto existem três scripts RECONHECIVEIS pelo bananapkg: <b>pre.sh</b> <b>pos.sh</b> <b>rm.sh</b>. Com estes scripts você pode fazer ainda mais a manipulação do seu pacote.

<p><b class="sub">pre.sh</b><br>
<p>Este script é manipulado pelo <b>plantpkg</b> e é executado na pré instalação do pacote, ou seja antes do pacote ser instalado. Toda rotina que você precisa antes do software estar instalado você poderá adicionar neste script! Como um exemplo vamos criar um usuário e grupo:</p>

<div id="code">
cat > "pre.sh" << 'EOF'<br>
# Adicionando grupo ao rsyncd<br>
groupadd -g 48 rsyncd<br>
<br>
# Adicionando usuário<br>
useradd -c "rsyncd Daemon" -d /home/rsync -g rsyncd -s /bin/false -u 48 rsyncd<br>
EOF
</div>

<p><b class="sub">pos.sh</b><br>
<p>Este script também é manipulado pelo utilitário <b>plantpkg</b> e é executado na pós instalação do pacote, tudo que você necessitar fazer na pós instalação é crucial por neste script. Supondo que eu precisasse na pós-instalação do pacote criar um link simbólico para o firefox em /usr/bin, devemos criar um script <b>pre.sh</b> e adicionar informações lá dentro! Lembrando que deve ser dentro do diretório <b>info/</b>.
Uma rotina clássica:</p>

<div id="code">
cat > "pos.sh" << 'EOF'
<br>
# Script para criar link simbólico do firefox para firefox-quantum<br>
ln -sf /usr/bin/firefox /usr/bin/firefox-quantum<br>
EOF
</div>

<p><b class="sub">rm.sh</b><br>
<p>O script rm.sh é executado na remoção do pacote e utilizado pelo utilitário burnpkg. <b>Este script é essencial</b> para uma limpeza mais profunda que o pacote deixou. Se você adicionou algumas rotinas no <b>pre.sh</b>/<b>pos.sh</b> de <u>criações</u> você precisa reverter tudo neste script. Afinal não queremos deixar sujeira na máquina do destinátario não é?<br>
Vamos a um exemplo clássico, adicionamos logo acima no script pre.sh e pos.sh a criação de Adicionar o grupo rsyncd e o usuário rsyncd. No script pos.sh criamos o link simbólico do firefox, então precisamos reverter isso para removê-los.</p>

<div id="code">
cat > "rm.sh" << 'EOF'<br>
# Removendo usuário rsyncd, como o grupo rsyncd foi criado especialmente para<br>
# este usuário, não é necessário remover o grupo, por padrão o grupo será removido<br>
# automaticamente.<br>
<b>userdel rsyncd</b>
<br>
<br>
# Removendo link-simbólico, criado no script <b>pos.sh</b><br>
<b>unlink /usr/bin/firefox-quantum</b><br>
EOF
</div>

<div id="nota">
<b>Nota!</b>
<ul>
    <li>É essencial dar permissão de execução para todos os scripts (pre.sh, pos.sh, rm.sh).</li>
    <li>Não se esqueça de inverter toda rotina que você fez no pre.sh e pos.sh e adicionar no rm.sh. A limpeza é essencial, com o tempo o sistema do destinatário pode ficar cheio de tranqueiras e isso é inadmissível.</li>
    <li>Análise é essencial, teste os scripts antes de empacotar.     
</ul>
</div>

<h3 id="instalar-atualizar-pacote" class="titulo">Como instalar/atualizar um pacote</h3>
<b>banana [opções] [Nomedopacote-Versão-Build.mz]</b><br><br>

<div id="code">
<b>-i</b>, <b>install</b> <b id="parametros">Instalação de pacote(s)</b><br>
<br>
<b>-u</b>, <b>upgrade</b> <b id="parametros">Upgrade do(s) pacote(s)</b><br>
<br>
</div>

<p>o parâmetro -i faz a instalação e atualização dos pacotes! A instalação é burra, ou seja ela não verifica versões, já se você usar a opção para atualizar o pacote ele faz a checkagem do nome, versão e build do pacote, se a versão for uma versão superior ele remove toda a hierarquia da versão anterior e instala a nova versão, isso é válido também para o build, se caso o build for maior ele faz o mesmo processo. Por isto o build é tão importante também!<br>
Se caso a Versão ou Build que você deseja "atualizar" for uma versão inferior ele não faz nada. Supondo que queira atualizar a versão do leafpad da 1.0 para versão 2.0:</p>

<div id="code">
# banana upgrade leafpad-2.0-1.mz<br>
<br>
Ou se caso você tem um leafpad com o build maior que tem no sistema!
<br>
<br>
# banana -u leafpad-2.0-2.mz
<br>
</div>

<div id="nota">
Nota!<br>
<ul>
    <li>Você viu que o Build é de extrema importância no empacotamento do bananaPKG, por isso é muito importante este campo. Sempre visualize a versão e o build, caso o build seja maior que o que você tem no sistema é sinal que o empacotador fez alguma modificação no mesmo e precisou reempacotar. Patches não contam aqui, já que na parte do empacotamento o software já está em binário.</li>
    <li>Se você decidir somente instalar um software de uma versão menor que a do que você tem no sistema o plantpkg irá fazer exatamente isto. Ele não faz a verificação de nada, apenas o que é necessário para o bom funcionamento e instalação do pacote.</li>
    <li>Para atualizar os pacotes o correto a se usar é o parâmetro -u ou upgrade.</li>
</ul> 
</div>

<h3 id="remover-pacote" class="titulo">Como remover um pacote</h3>
<b>banana [opções] [nome_do_pacote] ou [nome_do_pacote-versão]</b><br><br>

<div id="code">
<b>-r</b>, <b>remove</b> <b id="parametros">Remove pacote(s)</b><br>
</div>

<p>A ferramenta burnpkg serve para uma única finalidade, remover toda hierarquia do pacote no sistema. Sua sintaxe é bem simples é fácil. Supondo que queira remover o pacote leafpad do meu sistema, como root você necessita passar o parâmetro -b ou burn</p>

<b class="sub">-b, burn</b><br>
<p>O parâmetro -b ou burn serve para remover os pacotes, supondo que queira remover o pacote leafpad</p>

<div id="code">
# burnpkg burn leafpad<br>
</div>

<p>Se você ter mais de um pacote com o mesmo nome no sistema mas com versões diferentes não será póssivel remover o pacote somente com o parâmetro -b, burn. Ele irá fazer a listagem do(s) pacote(s) com suas respectivas versõe(s) e será imprimido na tela.
Exemplo clássico, supondo que tenho o leafpad com 2 versões diferentes no sistema a versão 1.0 e 2.0:</p>

<div id="code">
# banana remove leafpad<br>
[FOUND] leafpad-1.0<br>
[FOUND] leafpad-2.0<br>
</div>

<p>Então para fazer remoção neste caso eu precisarei passar o <b>nome</b> do pacote traço <b>versão</b>, ficando <b>nomepacote-versão</b>. Vamos supor que queira remover a versão do leafpad 2.0:</p>

<div id="code">
# banana remove leafpad-2.0<br>
</div>

<p><b class="sub">O parâmetro -y</b><br><br>
Para auto-confirmar sua escolha e não precisar passar o (y|Y|ENTER) para confirmar a remoção você pode passar o parâmetro -y, não importando sua posição, exemplo:</p>

<div id="code">
# <b>banana remove -y</b> leafpad<br>
<br>
A posição do parâmetro -y pode ser em qualquer lugar!<br>
<br>
# <b>banana remove</b> leafpad <b>-y</b><br>
</div>

<div id="nota">
<b>Nota!</b><br>
<ul>
    <li>Você pode excluir vários pacotes de uma vez, basta específicar.</li>
    <li>Para não precisar ficar passando a confirmação você pode usar o parâmetro -y após o -b ou burn.</li>
</ul>
</div>

<hr>


<!--
#####################################
COMPILAÇÃO
#####################################
-->


<h2>Compilação um caminho correto</h2>

Compilar um software não é fácil! Exige muita leitura e boas práticas que você deve seguir para chegar no objetivo de uma maneira correta. Este tópico visa abranger algumas boas práticas que você deve levar em consideração na hora de compilar um software.<br>
Não se esqueça que compilação e empacotamento não é brincadeira, é uma função honrosa e a mais especial de uma distribuição!
Leia com atenção, pesquise e pratique muito.<br>

<h3 id="compilacao" class="titulo">Quais parâmetros devo usar na compilação?</h3>
<p>A primeira coisa que você precisa fazer é ler no código fonte do programa o README, INSTALL ou qualquer outro documento que exista. Qualquer programador de quintal necessita disponibilizar como fazer a instalação do seu software, afinal nínguem tem vidência. Após você ter feito a leitura podemos prosseguir, <strike>normalmente</strike> os softwares são criados com as ferramentas do GNU e existe algum tipo de script para configuração, se os mesmos não forem criados com as ferramentas GNU, deve existir algum script que faz a configuração pré-compilação...</br>
Este script de configuração faz toda a configuração básica e verifica se todas as dependências estão supridas para o software ser compilado!<br>
Note que há uma diferença entre as dependências da compilação e do software em si. As vezes existem dependências para compilar o software mas após ter compilado não será mais necessário o mesmo instalado em sua máquina...<br>
Isto é uma questão de teste os quais você "compilador/empacotador" terá que testar!</p>

<p>Estes scripts também tem suas opções de help, o qual você pode verificar o que você pode habilitar/desabiliar na compilação! Isto fará todo efeito no software, por exemplo, se eu pedir para desabilitara interface gráfica do mplayer eu poderia passar algum parâmetro para o script dele chamado <b>configure</b>.</br>
Assim a interface não estaria presente quando o usuário fosse instalar. No ffmpeg por exemplo para ativar o ffplay que é um módulo presente no ffmpeg que toca áudio e vídeos, se não for passado o parâmetro <b>--enable-ffplay</b> o mesmo não estará presente após instalado.</br>
Por isso você deve ficar bem atento as opções que os softwares apresentam na compilação, afinal compilação é isso... O programador te dá as peças para você mesmo montar.</br>

<p>Normalmente os parâmetros que usamos como uma "receita" de bolo para uma instalação mais ideal seria como o exemplo com o configure:</p>

<div id='code'>
./configure \<br>
--prefix=/usr \<br>
--sysconfdir=/etc \<br>
--localstatedir=/var \<br>
--mandir=/usr/share/man \<br>
--docdir=/usr/share/doc
</div>

<p>Estes parâmetros básicos vão garantir que a localização do software não sujem o seu sistema:</p>

<p><b class="sub">--prefix=/usr</b><br>
<p>Garante que toda hierarquia do software como binários serão entregues em /usr/bin, suas bibliotecas em /usr/lib e os arquivos de desenvolvimento em /usr/include. Se caso você não especifique o --prefix normalmente a hierarquia fica em /usr/local, isso não é o correto e em TODOS os casos nenhuma distribuição aceitaria o pacote neste formato.</p>

<p><b class="sub">--sysconfdir=/etc</b><br>
<p>Esse parâmetro irá garantir que toda configuração do software será entregue em /etc.</p>


<p><b class="sub">--localstatedir=/var</b><br>
<p>Garante que todos os arquivos variáveis do software será entregue em /var</p>

<p><b class="sub">--mandir=/usr/share/man</b><br>
<p>Garante que todo manual do software fique em /usr/share/man, normalmente não será preciso especificar este parâmetro já que setamos o --prefix em /usr, na compilação já entendido que a hierarquia precisa ser está. Mas mal não faz também fazer a setagem manual.<br>
Outra coisa que você precisa confirmar é se no seu sistema qual o ideal que pode variar, no mazonOS a localização para manuais seria /usr/share/man, já na distribuição Slackware /usr/man. Então fica a seu critério fazer a avaliação.</p>

<p><b class="sub">--docdir=/usr/share/doc</b><br>
<p>Garante que toda a documentação sera entregue em /usr/share/doc/PROGRAMA-VERSÃO, normalmente este parâmetro é extra também já que especificamos o --prefix em /usr. Aqui também pode ter variações, na mazonOS fica em /usr/share/doc já na distribuição Slackware em /usr/doc.</p>

<p>Está é uma receita de bolo para uma boa compilação... Lembre-se de sempre fazer a leitura para ver quais parâmetros extras você pode passar!.</p>

<div id="nota">
Nota!
<ul>
    <li>Na hora da configuração use parâmetros genéricos, caso você for disponibilizar o pacote para alguém.</li>
    <li>Hierarquia de binários, bibliotecas, e arquivos de desenvolvimentos JAMAIS devem ficar em /usr/local, isto suja o sistema. Pois o programa pode tentar puxar por exemplo a biblioteca de /usr/lib e ela está em /usr/local/lib.</li>
</ul>
</div>


<hr>


<!--
########################
 DESENVOLVIMENTO
########################
-->

<h2>Desenvolvimento</h2>

<h3 id="listdescremove" class="titulo">/var/lib/banana/{list,desc,remove}</h3>
Na criação dos pacotes é gerado 3 diretórios que são <b>essenciais</b> para o funcionamento das ferramentos e funciona como um banco de dados. Estes diretórios ficam em /var/lib/banana/ e tem 3 variações, neste tópico você vai saber o que estes diretórios contém e por que é tão essencial.

<p><b class="sub">/var/lib/banana/list</b><br>
Este diretório é o banco de dados para as listas de instalação dos pacotes. Quando um pacote é "extraido" na / ele fica descontrolado, por isso na criação do pacote é criado uma lista para o usuário ter o controle de tudo que o pacote X instalou no sistema. Esta lista é usado especialmente pela ferramenta de remoção <b>burnpkg</b> e nada além disso. Na hora da remoção de um determinado software o burnpkg consulta este diretório!

<p><b class="sub">/var/lib/banana/desc</b><br>
Este diretório é o banco de dados para a descrição dos pacote que o empacotador cria no fakeroot no diretório info/desc. Na hora da extração com o <b>plantpkg</b> esse arquivo <b>desc</b> é movido para /var/log/desc com o nome do programa-versao-build.desc!
Este diretório é especial pois contém todo o formulário e identidade do(s) pacote(s) e suas especificações como (mantenedor, programa, versão, build, descrição, dependencias) entre outras informações.

<p><b class="sub">/var/lib/banana/remove</b><br>
Este diretório é usado diretamente pelo <b>burnpkg</b>, ele armazena scripts de instruções extras para remoção que o empacotador inseriu. Quando o burnpkg é invocado e se tudo ocorreu certo, antes de começar realmente a remoção ele chama o Script de remoção deste diretório, e depois consulta o /var/log/list para começar a remoção realmente. 

<h3 id="etcbanana" class="titulo">Arquivo de configuração em /etc/banana</h3>
Arquivos de configurações estão localizados em /etc/banana, é neste ditório que você pode encontrar o arquivo de configuração banana.conf e mudança de execução dos programas.

<h3 id="coresh" class="titulo">core.sh</h3>
<p>É a biblioteca de funções aonde todo o funcionamento principal das ferramentas estão! Até a versão 1.5 estas ferramentas eram a parte e se chamavam: burnpkg para remover pacotes, createpkg para criar pacotes e plantpkg para instalar pacotes.<br>
No trabalho que foi feito na nova versão todo programa foi reformulado e exportado tudo para estão biblioteca que fica localizada em /usr/libexec/banana/.</p>


<hr>

<!--
########################
 ENFEITES
########################
-->



<h3 id="enfeites" class="titulo">Enfeites do pacote</h3>
<p>Você faz o fakeroot por alguns motivos, entres eles o enfeite do pacote! Mas isso se o software necessitar, um software que executa em linha de comando terá poucos enfeites.<br>
Mas o que é o enfeite do pacote?<br>
O enfeite pode ser tudo que o usuário final vai ver ou não! É a etapa final que o pacote precisa para ficar organizado. Um exemplo clássico seria o Gimp por exemplo, que é um editor de imagens gráfico e irá precisar aparecer no menu do usuário! Normalmente o arquivo se chama PROGRAMA<b>.desktop</b>, e estará presente em usr/share/applications, você deve se certificar que este arquivo existe, se não existir você irá precisar criar toda a hierarquia de usr/share/applications e adicionar o nome do PROGRAMA.desktop e usar como base uma 
chamada tipo:<br></p>

<div id="code">
[Desktop Entry]<br>
Version=1.0<br>
Type=Application<br>
Name=<b>Leafpad</b><br>
Comment=<b>Aqui vai um PEQUENO comentário do que faz o Leafpad</b><br>
Exec=<b>leafpad</b><br>
Icon=<b>/usr/share/icons/gnome/48x48/apps/leafpad</b><br>
Terminal=<b>false</b><br>
StartupNotify=false<br>
</div>

<br>

<b class="sub">Name</b>
<p>O nome do programa que você está empacotando! Usamos o exemplo de Leafpad</p>


<b class="sub">Comment</b>
<p>Um pequeno comentário vai aqui, este comentário será exibido na hora que o usuário passa o mouse em cima do ícone.</p>

<b class="sub">Exec</b>
<p>A chamada do executável, você terá que ver dentro do fakeroot qual a hierarquia do executável! no caso o binário do leafpad vai para /usr/bin/leafpad. Desta maneira ficará global para todos usuários... Você pode fazer a chamada simplesmente com 'leafpad'. Você pode passar alguns parâmetros extras também na chamada quando o usuário clicar no ícone! Consulte o manual do programa para ver as funcionalidades que podem ser passadas no programa.</p>

<b class="sub">Icon</b>
<p>O ícone é o que é exibido no menu! Normalmente vem sem caminho absoluto, porém é um erro! <b>SEMPRE</b> passe o caminho absoluto do ícone para ter a certeza que o ícone será exibido. Em alguns casos o ícone fica sem aparecer o que é uma faha do empacotador.<br>
Verifique no seu fakeroot qual a localizaçao do ícone e lembre-se de setar no <b>.desktop</b> o caminho absoluto já com a /.</p>


<b class="sub">Terminal</b>
<p>Está é uma boa funcionalidade! O programa que você está empacotando vai ser executado no terminal? Exemplo clássico é um script em Shell ou Python por exemplo que executa via modo texto, mas você quer que tenha um ícone e o programa abra e rode em um terminal...<br>
Se está opção ser marcada como <b>true</b> você está especificando que será executado em um terminal, caso contrário utilize o <b>false</b></p>

<b class="sub">StartupNotify</b>
<p>Está opção se habilitada irá exibir uma notificação de inicialização do programa. Normalmente deixamos desabilitado está opção a não ser que o software realmente precise desta opção ativada.</p>

<h3>Arrumando alguns arquivos de DOC</h3>

<p>Após o enfeite acima, você irá precisar ainda do código fonte para verificar se existem arquivos em plain text que tem informações do programa! Exemplos básico:</p>

<p>AUTHORS COPYING HACKING INSTALL LICENSE NEWS README</p>

<p>Se existir arquivos que não necessariamente precisam ser os nomes acima, você precisa enviar estes arquivos para o seu fakeroot! Exemplo:</p>

<div id="code">
cp -a \<br>
  AUTHORS COPYING HACKING INSTALL LICENSE NEWS README \<br>
  <b>DIRETÓRIO_PACOTE_FAKEROOT</b>/usr/share/doc/PACOTE-VERSÃO/<br>
</div>



<div id="nota">
Nota!
<ul>
    <li>O .desktop de exemplo que passamos acima é apenas para exemplo, normalmente os softwares maiores utilizam um .desktop imenso, e você terá que pesquisar e arrumar da sua forma, se caso necessário.</li>
</ul>
</div>


<h3 id="strip" class="titulo">Strip Now</h3>
<p>Após a compilação você necessita tirar a inclusão de símbolos nos objetos do binário, o comando que ajudará em reduzir o binário em até 60% será o comando strip! Você deve verificar se o binario já está ou não estripado, para isto utilize o comando file:</p>

<div id="code">
# <b>file</b> usr/bin/nano<br>
usr/bin/nano: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, not stripped
</div>

<p>Perceba que existe um campo que está como "not stripped", ou seja ele ainda não está estripado, vamos verificar o tamanho do arquivo para tirar a conclusão depois, para isto utilizamos o comando du com os parâmetros -sh:</p>

<div id="code">
# <b>du</b> -sh usr/bin/nano<br>
264K	usr/bin/nano
</div>

<p>O binário está com o tamanho 264K, e ainda não está estripado, então vamos estripar para reduzir ainda mais o tamanho, para isto utilizamos o comando strip com o parâmetro -s e seguida vamos usar o du -sh para ver o tamanho novamente:</p>

<div id="code">
# <b>strip</b> -s usr/bin/nano<br>
<br>
# <b>du</b> -sh usr/bin/nano<br>
112K	usr/bin/nano
</div>

<p>Perceba que não reduziu muito o tamanho, mas em software maiores a diferença é incrivel! Olha só com um programa como do filezilla:</p>

<div id="code">
# <b>du</b> -sh usr/bin/filezilla<br>
168M	usr/bin/filezilla<br>
<br>
# <b>strip</b> -s usr/bin/filezilla<br>
<br>
# <b>du</b> -sh usr/bin/filezilla<br>
5,5M	usr/bin/filezilla
</div>

<p>O binário de 168M reduziu para 5,5M! Será que faz diferença? é essencial usar o strip em binários, <b>JAMAIS</b> se esqueça pois isso faz toda diferença no tamanho do pacote.</p>


</body>
</html>
